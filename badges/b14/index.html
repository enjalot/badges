<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script src="../../d3.js"></script>
<style>
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  margin: 0;
  padding: 0;
}
</style>
<script>

// originally from: bl.ocks.org/RandomEtc/5165219

var w = 1050,
    h = 1500

var width = w, height = h

tributary = { sw: w, sh: h }

  var body = d3.select("body").style("background-color", "rgb(85,36,106)").attr('id', 'display')
  var canvas = body.append('canvas').attr({width: w, height: h})
  var ctx = canvas.node().getContext('2d')
  tributary.ctx = ctx

//laser math 
//http://spot.colorado.edu/~lessley/pdf%20stuff/lasermath2.pdf
//http://spot.colorado.edu/~lessley/rosecurves.html

var x0 = 544;
var y0 = 623;
  
var n = 70;
//main parameters, ratio matters
var a = 5.74228 * n;
var b = 1.296 * n;
//var b = (n-1)/(n+10);

//x tilt? (x radius)
var hx = -115;
//y tilt? (y radius)
var hy = 34;

//frequency, adjust fbase
var fbase = 28.2296;
var omega0 = 2 * Math.PI * fbase;

//slow down or speed up the tracers
var om = omega0 * 0.07247536128;

//how fast it fades
var erasing = 0.99;
//number of points in the paths (more = smoother)
var linen = 1;

//color of the paths
var cs = d3.interpolateHsl("#1D0808", "#350909");
var sopacity = -0.28;
//color of the tracers
var cf = d3.interpolateHsl("#ffd1d1", "#ff7f8c");
var fopacity = 0.7;
//radius of the tracers
var radius = 5;
// number of tracers
var nt = 600;
//time offset for each tracer
var to = 0.60314;

function x(t, o) {
  //return (a - b) * Math.cos(omega0*t) + h * Math.cos(omega0*t*(a/b-1));
  return (a - b) * Math.cos(o*t) + hx * Math.cos(o*t*(a-b)/b);
  //return h * Math.cos(t*Math.PI);
}
function y(t, o) {
  //return (a - b) * Math.sin(omega0*t) - h * Math.sin(omega0*t*(a/b-1));
  return (a - b) * Math.sin(o*t) - hy * Math.sin(o*t*(a-b)/b);
  //return h * Math.sin(t*Math.PI);
}

function circle(ctx, p) {
    //ctx.fillStyle = 'hsla(0,0%,' + 70 +'%,' + 1 + ')';
    ctx.beginPath();
    ctx.arc(p[0],p[1],radius,0,2*Math.PI);
    ctx.fill();
}
function line(ctx) {  
  ctx.beginPath();
  var i;
  for(i=0;i<linen;i++) {
      //ctx.strokeStyle = c(i/linen);
    ctx.lineTo(x0 + x(i/linen, omega0), y0 + y(i/linen, omega0));
  }
  ctx.stroke();
  
}

tributary.init = function(ctx) {
  d3.select("#display").style("background-color", "rgb(100,50,50)")
  ctx.globalCompositeOperation = 'source-over';
  
};
tributary.run = function(ctx,t) {
    //tributary.clear(); //helper function to clear the canvas 
    ctx.fillStyle = "rgba(120,40,50," + erasing +  ")";
    ctx.fillRect(0,0,tributary.sw,tributary.sh);
    var tt = Math.cos(t)/2;
    
    var p;

    ctx.strokeStyle = cs(tt);
  line(ctx);
    
    p = [x0 + x(tt, om), y0 + y(tt, om)]; 
    ctx.fillStyle = cf(tt);
    circle(ctx, p);
  
    
    var i = 0;
    for(i = 0; i < nt; i++) {
      //p = [x0 + x(tt+i*tt/2, om), y0 + y(tt+i*tt/2, om)]; 
      p = [x0 + x(tt+i*to, om), y0 + y(tt+i*to, om)]; 
      ctx.fillStyle = cf(i/nt);
      circle(ctx, p);
    }
    
  
};
var t = 0;
tributary.step = function() {
  t+= 0.1;
  tributary.run(tributary.ctx, t);
}


var t = 0; steps = 0
function step() {
  if(steps++ > 10) return
  t+= 0.1;
  tributary.run(tributary.ctx, t);
}


tributary.init(ctx)

is_ready = true

;(function(){
  if(!window.step) window.step = null
  // debuggin snippet for when not in an iframe
  if(window.self !== window.top) return
  ;(function check(){ if(!is_ready) return setTimeout(check, 100); setInterval(step, 100) })()
})()

</script>