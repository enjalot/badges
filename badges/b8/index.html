<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script src="../../d3.js"></script>
<style>
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  margin: 0;
  padding: 0;
}

.cm-s-lesser-dark.CodeMirror { background: #1e2426; color: #696969;  }
.cm-s-lesser-dark div.CodeMirror-selected {background: #064968 !important;} /* 33322B*/
.cm-s-lesser-dark span.cm-variable { color:#22EFFF; }
.cm-s-lesser-dark span.cm-variable-2 { color: #FFCCB4; }
.cm-s-lesser-dark span.cm-variable-3 { color: white; }
.cm-s-lesser-dark span.cm-string { color: Chartreuse; }
.cm-s-lesser-dark span.cm-string-2 {color: Chartreuse;}
.cm-s-lesser-dark span.cm-def {color: #FFCCB4; opacity: 1.0}
.cm-s-lesser-dark span.cm-bracket { color: #EBEFE7; }
.cm-s-lesser-dark pre { color:#FFF; }
.cm-s-lesser-dark span.cm-comment { color: #AFB4B4;}
.cm-s-lesser-dark span.cm-property {color: #FDA676;}
.cm-s-lesser-dark span.cm-number { color: #FF92EE;}
.cm-s-lesser-dark span.cm-keyword { color: #FFFF18; }
.cm-s-lesser-dark .CodeMirror-cursor { border-left: 1px solid white !important; }


</style>
<script>

// originally from: bl.ocks.org/RandomEtc/5165219

var w = 1050,
    h = 1500

tributary = { sw: w, sh: h }


// original by @zeffii
d3.select("body").style("background-color", "#34495e").append('svg')

var svg = d3.select("svg");

// unfinished.


// - 20 rings. Initial ring has 6 vertices
// - each consecutive ring has 6 additional vertices
// - radius increases by a constant with each extra ring. 
// - for each ring 6 vertices must be connected twice to the next ring.
// - hints of sporadic randomness of delta distance and radial_offset

var vertex_color = { "stroke": "#6BE7FF"},
  stroke_style = { 
      "fill": "none", 
      "stroke": "#63bab4", 
      "stroke-width": 1.4 + "px"
    };

var npos = nautilus_pos = {x: tributary.sw/2, y: tributary.sh/2};

var defs = svg.append("defs"),
  locator = defs.append("g").classed("locator", true),
    drawing = svg.append("g").classed("main_group", true),
  loc_group = drawing.append("g").classed("example_locator", true),
  edge_group = drawing.append("g").classed("edges_locator", true),
  index_group = drawing.append("g").classed("edges_locator", true);

// set midpoint of this drawing
drawing.attr("transform", "translate(" + [npos.x, npos.y] + ")")

// radial array variables
var radius = 45,
  radial_offset = 0.2167, // <---------------- radial twist
  num_rings = 21,
  array_collection = [],
  delta = radius * 1.12582, // max distance to connect edges
    radial_jump = (Math.PI * 2) / 70;

d3.select("svg").selectAll().remove();
render();


var steps = 0
window.step = function() {
  if(steps++ > 8) return
  radial_offset += 0.1;
  delta += 3;
  d3.select("svg").selectAll().remove();
  render();
}

function render() {
// definitions of these found in helpers section below
define_marker()
fill_array_collection()
//draw_all(draw_vertex)
//draw_all(draw_index)
draw_star()

/* --- main loop --- */

for (var i in d3.range(num_rings-1)){
 
    var _i = parseInt(i);
    var _this = array_collection[_i];
    var _next = array_collection[_i + 1];

    var connected_set_indexed = [];
    var connected_set = [];
  
    _this.forEach(function(pos1, _j, array){
        var vert_count = _next.length - 1;

        /* 
        - [ ] keep track, doesn't yet
        - [ ] record all double connections
        - [ ] remove double connections, until 6 remain
        - [ ] also remove potentially cross wired
        */

        // temporary, unsure about criteria      
        d3.range(_next.length).forEach(function(id){
          
            var check_index = parseInt(id);
                        
            if ((check_index < 0) || (check_index > vert_count)){
                check_index += vert_count
            }
          
            var pos2 = _next[check_index];
            var distance = check_distance(pos1, pos2)
           
            if (distance <= delta){
                connected_set_indexed.push({
                  idx1: _i, 
                  idx2: _j, 
                  coordinates: [pos1, pos2]
                })
            }
            
        })
    })
    
    // process connected_set_indexed into connected_set
    connected_set_indexed.forEach(function(edge){
        // stuff here.
      connected_set.push(edge.coordinates)  
    })
    
    
    // at this point the set should have been reduced to the essentials
    draw_edges(connected_set)
    
}





// helpers
function draw_all(fn){
    /*  input: a function (draw_vertex or draw_index)
      behaviour: perform function on each element of array_collection.
      output: none
    */
    
    for (var i in d3.range(num_rings)){
        var _this = array_collection[+i];
              
        _this.forEach(function(pos, idx){
            fn(pos, idx)
        })
    }
}

function draw_vertex(pos, i){
    loc_group.append("use")
      .attr("xlink:href", "#marker")
      .style(stroke_style)
      .style(vertex_color)
      .attr("transform", "translate(" + [pos.x, pos.y] + ")") 
}

function draw_index(pos, i){
    var crad = 8;
    var idx = index_group.append("g")
      .attr({"transform": "translate(" + [pos.x + (crad/2), pos.y + (crad/2)] + ")"})
    
    idx.append("circle")
      .attr({fill: "#080808", stroke: "none"})
      .attr({cx: -crad/2, cy: -crad/2, r: crad})

    idx.append("text")
      .text(i)
      .attr({"text-anchor": "middle", "font-size": 9, "x": -crad/2, "y": -1})
      .style({fill: "#eaeaea"})
}

function draw_star(){
    array_collection[0].forEach(function(pos){
       draw_edge({x:0, y:0}, pos)    
  })
}

function draw_edges(connected_set){
    connected_set.forEach(function(positions){
        draw_edge(positions[0], positions[1])
    })
}

function draw_edge(pos1, pos2){
    var _positions = [pos1.x, pos1.y, pos2.x, pos2.y];
  var _path = "M" + _positions.join(" ") + "z";
    
    edge_group.append("path")
    .attr("d", _path)
        .style(stroke_style)
}

function check_distance(pos1, pos2){
  var a = Math.abs(Math.max(pos1.x, pos2.x) - Math.min(pos1.x, pos2.x)),
      b = Math.abs(Math.max(pos1.y, pos2.y) - Math.min(pos1.y, pos2.y)),
        c = Math.sqrt((a*a) + (b*b));
    return c
}

function define_marker(){
    var md = marker_dimension = 4;
  var marker_path = ["M", -md, 0, md, 0, "M", 0, -md, 0, md, "z"].join(" ");
    locator.append("path")
        .attr("id", "marker")
        .attr("d", marker_path) 
}

function fill_array_collection(){
    /* to implement: 
      add occasional radial_offset adjustment, to disorder indices 
    */
    for (var i in d3.range(num_rings)){
        var num_iter = 6 + (i * 6);
        var new_radius = (radius + (i * radius));
        var _this = generate_array(i, num_iter, new_radius, radial_offset);
        array_collection.push(_this)
    }
}

function generate_array(i, num_iterations, radius, radial_offset){
  var n_array = [];  
    if ( i % 5 === 0) radial_offset += .27
    if ( i % 6 === 0) radial_offset += .58
    if ( i % 8 === 0) radial_offset += .9
    var _offset = radial_offset * i
    
    for (i in d3.range(num_iterations)){
        n_array.push(position(i, num_iterations, radius, _offset));
    }
    
  return n_array
}

function rad(deg){ 
    return ((2 * Math.PI) / 360) * deg 
}

function position(i, num_iterations, radius, radial_offset){ 
  var rot = (360 / num_iterations) * i,
      rads = rad(rot),
      x = Math.sin(rads + radial_offset) * radius,
      y = Math.cos(rads + radial_offset) * radius;
  
    return {x:x, y:y}
}


}

/*EOF*/



is_ready = true

;(function(){
  if(!window.step) window.step = null
  // debuggin snippet for when not in an iframe
  if(window.self !== window.top) return
  ;(function check(){ if(!is_ready) return setTimeout(check, 100); setInterval(step, 100) })()
})()


function translate(x, y){
  return "translate(" + [x, y] + ")"
}  
function rotate(amount){
  return "rotate(" + amount + ")"
}  
function scale(){
  var args = arguments;
  var injection = (args.length === 1) ? args[0] : [args[0], args[1]];
  return "scale(" + injection + ")"
}
  
// alias console.log as log()
  
function log(text) { return console.log(text); }  

</script>