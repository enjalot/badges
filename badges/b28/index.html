<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script src="../../d3.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>
<style>
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  margin: 0;
  padding: 0;
  background-color: black;
}

body{
  width: 1050px;
  height: 1500px;
  background-color: #333;
}

.stroke {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

.fill {
  fill: #3498db;
}

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .5
}

.land {
  fill: #2ecc71;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: .5px;
}

</style>
<script>

var w = 1050, h = 1500

var width = w, height = h



//Try changing all these parameters
//Layout properties
var n = 40;
var m = 30;
var tributary = { sw: w, sh: h }
var trib = {}
trib.spacing = 40;
trib.opacity = 0.9;
trib.stroke_width = 20;

//Sin wave function
//y = amplitude * sin( omega * theta + phase)
trib.amplitude = 21;
trib.theta = 11;
trib.omega = 0.0;
trib.phase = 0.1;

var colors = [
    '#D40067'
    , '#4DA9DF'
    , '#00ff00'
    , '#ff0000'
    
]

var svg = d3.select('body').append('svg')
  .attr({width: w, height: h})

function draw(){
  svg.selectAll('*').remove()

//interpolate over multiple colors
var color_scale = function(i) {
    var num_interps = colors.length -1
    
    var ord = d3.scale.linear()
        .domain([0, n])
        .range([0, num_interps])
    
    var section = parseInt(ord(i))
    //console.log("section", section)
    var section_size = n / num_interps
    //get the two colors we want to interpolate between
    var col_range = [colors[section], colors[section+1]]
    
    var col_scale = d3.scale.linear()
        .domain([section * section_size, (section+1) * section_size])
        //.interpolate(d3.interpolateRgb)
        .interpolate(d3.interpolateHsl)
        .range(col_range)
    
    return col_scale(i)
    
}
/*
var color = d3.scale.linear()
    .domain([0, n])
    //.interpolate(d3.interpolateRgb)
    .interpolate(d3.interpolateHsl)
    .range(['#D40067', '#4DA9DF'])
*/    
var color = color_scale



var sw = tributary.sw * 1.1;//parseInt(d3.select("svg").style("width"))
//make the sin waves extend past the width a little
//sw += .1 * sw
var sh = tributary.sh;//parseInt(d3.select("svg").style("height"))


var lines = [ ];
for (i in d3.range(n)) {

    var data = d3.range(m) 
    lines.push({ 
        index: i,
        data: data
    })
}

var xscale = d3.scale.linear()
    .domain([0, m])
    .range([-.1*sw, sw])

function line_maker( data ) {
    var freq = trib.omega * data.index
    var svgline = d3.svg.line()
        .x(function(d,i) {
            return xscale(d);
        })
        .y(function(d,i) {
            var th = d/m * trib.theta
            var ph = (n-data.index) * trib.phase
            var y = trib.amplitude * Math.sin(freq * th + ph );
            return y
        })
        .interpolate("basis")
        //.interpolate("linear")
    return svgline(data.data);
}

function lineenter(d, i) {
    d3.select(this).selectAll("path.path")
        .data([d])
        .enter()
    .append("svg:path")
        .attr("class", "path")
        .attr("stroke-width", trib.stroke_width)
        //.attr("stroke-width", function(e,i) { return e.width;})
        .attr("stroke", "#fff")
        .attr("fill", "none")
    update_spacing()
}

function update_spacing()
{
    var th = trib.spacing * n;
    var hscale = d3.scale.linear()
        .domain([0, n])
        .range([0, sh])
    d3.selectAll("g.line path")
        .attr("transform", function(d, i) { 
            //return "translate(" + [0, th - spacing * d.index] + ")"; 
            return "translate(" + [0, 10+sh/2 + th / 2 - trib.spacing * d.index] + ")"; 
        })
}

var line = svg.selectAll("g.line")
    .data(lines)
  .enter().append("svg:g")
    .attr("class", "line")
    .each(lineenter);




/*
var opacity = d3.scale.linear()
    .domain([0, n])
    .range([1, .4])
*/
  
d3.selectAll("g.line path") 
    .attr("d", function(d,i) {
        return line_maker(d) 
    })
    .attr("stroke", function(d,i) { return color(d.index);})
    .attr("opacity", trib.opacity);



}


window.is_ready = true

var steps = 0
function step() {
  if(steps++ > 10) return
  draw()
trib.omega = 0.5 * steps / 9;
trib.amplitude = 30 * steps / 9
trib.phase = -3.3
trib.theta = 10
}

;(function(){
  if(!window.step) window.step = null
  // debuggin snippet for when not in an iframe
  if(window.self !== window.top) return
  ;(function check(){ if(!window.is_ready) return setTimeout(check, 100); setInterval(step, 100) })()
})()

</script>